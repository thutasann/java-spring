# Key patterns

## A. Sliding Window

    When to Use: Subarray problems (e.g., maximum sum, longest substring).
    Key Idea: Expand/shrink the window based on conditions.
    Example: Longest Substring Without Repeating Characters

## B. Two Pointers

    When to Use: Sorted arrays or lists (e.g., finding pairs).
    Key Idea: Use two pointers to narrow down the search space.
    Example: Two Sum II - Input Array Is Sorted

## C. Hash Maps

    When to Use: Fast lookups (e.g., frequency count, duplicates).
    Key Idea: Store data in key-value pairs to optimize searches.
    Example: Two Sum

## D. Binary Search

    When to Use: Search problems in sorted arrays.
    Key Idea: Divide and conquer to find the target efficiently.
    Example: Binary Search

## E. Backtracking

    When to Use: Recursive exploration (e.g., permutations, combinations).
    Key Idea: Explore all possibilities and backtrack when conditions fail.
    Example: N-Queens

## F. Dynamic Programming

    When to Use: Optimization problems with overlapping subproblems.
    Key Idea: Solve smaller subproblems, store results (memoization/tabulation).
    Example: Climbing Stairs

## G. Graphs

    When to Use: Problems involving connections (e.g., shortest path).
    Key Idea: Use BFS, DFS, or Dijkstraâ€™s Algorithm.
    Example: Clone Graph

## H. Deque
